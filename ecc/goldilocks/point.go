package goldilocks

import (
	"errors"

	fp "github.com/cloudflare/circl/math/fp448"
)

// Point is a point on the Goldilocks Curve.
type Point struct{ x, y, z, ta, tb fp.Elt }

// FromAffine creates a point from affine coordinates.
func FromAffine(x, y *fp.Elt) (*Point, error) {
	P := &Point{
		x:  *x,
		y:  *y,
		z:  fp.One(),
		ta: *x,
		tb: *y,
	}
	if !(Curve{}).IsOnCurve(P) {
		return P, errors.New("Point not on Curve")
	}
	return P, nil
}

// FromBytes returns a point from the input buffer.
func FromBytes(in []byte) (*Point, error) {
	if len(in) < fp.Size+1 {
		return nil, errors.New("wrong input length")
	}
	var err = errors.New("invalid decoding")
	P := &Point{}
	signX := in[fp.Size] >> 7
	copy(P.y[:], in[:fp.Size])
	p := fp.P()
	if !isLessThan(P.y[:], p[:]) {
		return nil, err
	}

	u, v := &fp.Elt{}, &fp.Elt{}
	one := fp.One()
	fp.Sqr(u, &P.y)                // u = y^2
	fp.Mul(v, u, &paramD)          // v = dy^2
	fp.Sub(u, u, &one)             // u = y^2-1
	fp.Sub(v, v, &one)             // v = dy^2-1
	isQR := fp.InvSqrt(&P.x, u, v) // x = sqrt(u/v)
	if !isQR {
		return nil, err
	}
	fp.Modp(&P.x) // x = x mod p
	if fp.IsZero(&P.x) && signX == 1 {
		return nil, err
	}
	if signX != (P.x[0] & 1) {
		fp.Neg(&P.x, &P.x)
	}
	P.ta = P.x
	P.tb = P.y
	P.z = fp.One()
	return P, nil
}

// IsIdentity returns true is P is the identity Point,
func (P *Point) IsIdentity() bool {
	return fp.IsZero(&P.x) && !fp.IsZero(&P.y) && !fp.IsZero(&P.z) && P.y == P.z
}

// IsEqual returns true if P is equivalent to Q.
func (P *Point) IsEqual(Q *Point) bool {
	l, r := &fp.Elt{}, &fp.Elt{}
	fp.Mul(l, &P.x, &Q.z)
	fp.Mul(r, &Q.x, &P.z)
	fp.Sub(l, l, r)
	b := fp.IsZero(l)
	fp.Mul(l, &P.y, &Q.z)
	fp.Mul(r, &Q.y, &P.z)
	fp.Sub(l, l, r)
	b = b && fp.IsZero(l)
	fp.Mul(l, &P.ta, &P.tb)
	fp.Mul(l, l, &Q.z)
	fp.Mul(r, &Q.ta, &Q.tb)
	fp.Mul(r, r, &P.z)
	fp.Sub(l, l, r)
	b = b && fp.IsZero(l)
	return b
}

// Neg obtains the inverse of the Point.
func (P *Point) Neg() { fp.Neg(&P.x, &P.x); fp.Neg(&P.ta, &P.ta) }

// ToAffine returns the x,y affine coordinates of P.
func (P *Point) ToAffine() (x, y fp.Elt) {
	fp.Inv(&P.z, &P.z)       // 1/z
	fp.Mul(&P.x, &P.x, &P.z) // x/z
	fp.Mul(&P.y, &P.y, &P.z) // y/z
	fp.Modp(&P.x)
	fp.Modp(&P.y)
	fp.SetOne(&P.z)
	P.ta = P.x
	P.tb = P.y
	return P.x, P.y
}

// ToBytes stores P into a slice of bytes.
func (P *Point) ToBytes(out []byte) error {
	if len(out) < fp.Size+1 {
		return errors.New("invalid decoding")
	}
	x, y := P.ToAffine()
	out[fp.Size] = (x[0] & 1) << 7
	return fp.ToBytes(out[:fp.Size], &y)
}

// MarshalBinary encodes the receiver into a binary form and returns the result.
func (P *Point) MarshalBinary() (data []byte, err error) {
	data = make([]byte, fp.Size+1)
	err = P.ToBytes(data[:fp.Size+1])
	return data, err
}

// UnmarshalBinary must be able to decode the form generated by MarshalBinary.
func (P *Point) UnmarshalBinary(data []byte) error { Q, err := FromBytes(data); *P = *Q; return err }
