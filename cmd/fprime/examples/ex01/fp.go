// Code generated by github.com/cloudflare/circl/cmd/fprime DO NOT EDIT.

// Package ex01 is an instance of fprime.
package ex01

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"
	"math/bits"
)

const (
	// Size in bytes of elements.
	_N8 = 32
	// Number of uint words for elements.
	_Nw = 4
	// Montgomery reduction constant -p^-1 mod 2^_Nw.
	_Mu = 14314504021056784825
)

var order = Elem{[_Nw]uint{
	0x2013481d1f6e5377,
	0x6e3bf623d5262028,
	0x3e660a909d838d72,
	0xa9fb57dba1eea9bc,
}}

var rmodp = Elem{[_Nw]uint{
	0xdfecb7e2e091ac89,
	0x91c409dc2ad9dfd7,
	0xc199f56f627c728d,
	0x5604a8245e115643,
}}

var pMinusTwo = [_N8]byte{
	0x75, 0x53, 0x6e, 0x1f, 0x1d, 0x48, 0x13, 0x20,
	0x28, 0x20, 0x26, 0xd5, 0x23, 0xf6, 0x3b, 0x6e,
	0x72, 0x8d, 0x83, 0x9d, 0x90, 0x0a, 0x66, 0x3e,
	0xbc, 0xa9, 0xee, 0xa1, 0xdb, 0x57, 0xfb, 0xa9,
}

var errArithmetic = errors.New("arithmetic error")

// Elem is
type Elem struct{ v [_Nw]uint }

type bigElem [2 * _Nw]uint

func One() Elem   { return rmodp }
func Order() Elem { return order }
func (z *Elem) fromMontgomery() *Elem {
	var t Elem
	t.Mul(z, &Elem{[_Nw]uint{0x1}})
	return &t
}

func (z Elem) String() string {
	// t := z.fromMontgomery()
	s := "0x"
	f := fmt.Sprintf("%%0%vx", 2*(bits.UintSize/8))
	for i := range z.v {
		s += fmt.Sprintf(f, z.v[_Nw-1-i])
	}
	return s
}

// CMov sets z = x if b is different from zero.
func (z *Elem) CMov(x *Elem, b uint) {
	_, c := bits.Sub(0, b, 0)
	m := -c
	for i := range z.v {
		z.v[i] = (z.v[i] &^ m) | (x.v[i] & m)
	}
}

// cacc conditionally updates z = z+x if b is different from zero.
func (z *Elem) cacc(x *Elem, b uint) uint {
	_, k := bits.Sub(0, b, 0)
	m := -k
	c := uint(0)
	z.v[0], c = bits.Add(z.v[0], m&x.v[0], c)
	z.v[1], c = bits.Add(z.v[1], m&x.v[1], c)
	z.v[2], c = bits.Add(z.v[2], m&x.v[2], c)
	z.v[3], c = bits.Add(z.v[3], m&x.v[3], c)
	return c
}

func (z *Elem) ToBigInt() *big.Int {
	t := z.fromMontgomery()
	x := make([]big.Word, _Nw)
	for i := range z.v {
		x[i] = big.Word(t.v[i])
	}
	return new(big.Int).SetBits(x)
}

func (z *Elem) Rand(r io.Reader) (n int, err error) {
	b := make([]byte, 8*_Nw)
	n, err = r.Read(b)
	for i := range z.v {
		z.v[i] = uint(binary.LittleEndian.Uint64(b[8*i : 8*(i+1)]))
	}
	return
}

func (z *Elem) Add(x, y *Elem) uint {
	c := uint(0)
	z.v[0], c = bits.Add(x.v[0], y.v[0], c)
	z.v[1], c = bits.Add(x.v[1], y.v[1], c)
	z.v[2], c = bits.Add(x.v[2], y.v[2], c)
	z.v[3], c = bits.Add(x.v[3], y.v[3], c)
	// fmt.Println(">", c, z)
	c = z.cacc(&rmodp, c)
	c = z.cacc(&rmodp, c)
	// fmt.Println(">", c, z)
	// fmt.Println(">", c, z)
	if c != 0 {
		fmt.Println(x, y)
		panic(errArithmetic)
	}
	return c
}

func (z *Elem) Sub(x, y *Elem) uint {
	c := uint(0)
	z.v[0], c = bits.Sub(x.v[0], y.v[0], c)
	z.v[1], c = bits.Sub(x.v[1], y.v[1], c)
	z.v[2], c = bits.Sub(x.v[2], y.v[2], c)
	z.v[3], c = bits.Sub(x.v[3], y.v[3], c)
	return c
}

func (z *Elem) Mul(x, y *Elem) {
	var t bigElem
	t.Mul(x, y)
	z.red(&t)
}

func (z *Elem) Sqr(x *Elem) {
	var t bigElem
	t.Sqr(x)
	z.red(&t)
}

func (z *bigElem) Mul(x, y *Elem) {
	var cc, carry uint
	for i := 0; i < _Nw; i++ {
		hi, lo := bits.Mul(x.v[i], y.v[0])
		z[i], cc = bits.Add(lo, carry, 0)
		carry, _ = bits.Add(hi, 0, cc)
	}
	z[_Nw] = carry

	for j := 1; j < _Nw; j++ {
		carry = uint(0)
		for i := 0; i < _Nw; i++ {
			hi, lo := bits.Mul(x.v[i], y.v[j])
			lo, cc := bits.Add(lo, carry, 0)
			hi, _ = bits.Add(hi, 0, cc)
			z[i+j], cc = bits.Add(z[i+j], lo, 0)
			carry, _ = bits.Add(hi, 0, cc)
		}
		z[j+_Nw] = carry
	}
}

func (z *bigElem) Sqr(x *Elem) {
	var carry uint
	for j := 0; j < _Nw; j++ {
		carry = 0
		for i := j + 1; i < _Nw; i++ {
			hi, lo := bits.Mul(x.v[i], x.v[j])
			lo, cc := bits.Add(lo, carry, 0)
			hi, _ = bits.Add(hi, 0, cc)
			z[i+j], cc = bits.Add(z[i+j], lo, 0)
			carry, _ = bits.Add(hi, 0, cc)
		}
		z[j+_Nw] = carry
	}

	for i := 2*_Nw - 1; i > 0; i-- {
		z[i] = (z[i] << 1) | (z[i-1] >> (bits.UintSize - 1))
	}

	carry = 0
	for i := 0; i < _Nw; i++ {
		hi, lo := bits.Mul(x.v[i], x.v[i])
		z[2*i+0], carry = bits.Add(z[2*i+0], lo, carry)
		z[2*i+1], carry = bits.Add(z[2*i+1], hi, carry)
	}
}

func (z *Elem) red(x *bigElem) {
	var cout uint
	for i := 0; i < _Nw; i++ {
		carry := uint(0)
		w := _Mu * x[i]
		for j := 0; j < _Nw; j++ {
			hi, lo := bits.Mul(order.v[j], w)
			lo, cc := bits.Add(lo, carry, 0)
			hi, _ = bits.Add(hi, 0, cc)
			x[i+j], cc = bits.Add(x[i+j], lo, 0)
			carry, _ = bits.Add(hi, 0, cc)
		}
		x[i+_Nw], carry = bits.Add(x[i+_Nw], carry, 0)
		for j := i + _Nw + 1; j < 2*_Nw; j++ {
			x[j], carry = bits.Add(x[j], 0, carry)
		}
		cout += carry
	}
	for i := range z.v {
		z.v[i] = x[i+_Nw]
	}
	b := z.cacc(&rmodp, cout)
	if b != 0 {
		panic(errArithmetic)
	}
}

func (z *Elem) Exp(x *Elem, n []byte) {
	t := One()
	for i := 8*len(n) - 1; i >= 0; i-- {
		t.Sqr(&t)
		bit := (n[i/8] >> uint(i%8)) & 0x1
		if bit != 0 {
			t.Mul(&t, x)
		}
	}
	*z = t
}

func (z *Elem) Inv(x *Elem) { z.Exp(x, pMinusTwo[:]) }
