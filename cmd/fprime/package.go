package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"math/big"
	"math/bits"
	"path/filepath"
	"strings"
	"text/template"
)

type pkgBuilder struct {
	Cfg       Config
	N8        uint    // Size in bytes of elements
	Nw        uint    // Number of words to store P
	Nw2       uint    // 2*Nw
	P         big.Int // Prime modulus
	R         big.Int // 2^Nw
	RmodP     big.Int // 2^Nw mod P
	Mu        uint    // (-P)^-1 mod 2^Nw
	PMinusTwo big.Int // P-2
}

func (b *pkgBuilder) render(outFile string) {
	b.pkg(outFile)
	dir, name := filepath.Split(outFile)
	res := strings.Split(name, ".")
	b.tests(filepath.Join(dir, res[0]+"_test."+res[1]))
}

func (b *pkgBuilder) tests(outFile string) {
	tl, err := template.New(b.Cfg.PkgName).Parse(b.buildTest())
	if err != nil {
		panic(err)
	}
	var buf bytes.Buffer
	err = tl.Execute(&buf, b)
	if err != nil {
		panic(err)
	}
	err = ioutil.WriteFile(outFile, buf.Bytes(), 0600)
	if err != nil {
		panic(err)
	}
}

func (b *pkgBuilder) buildTest() string {
	return strings.Join([]string{
		autogenerated,
		declPkgTest,
		importsTest,
		addBench,
		"",
	}, "\n")
}
func (b *pkgBuilder) pkg(outFile string) {
	tl, err := template.New(b.Cfg.PkgName).Parse(b.buildPackage())
	if err != nil {
		panic(err)
	}
	var buf bytes.Buffer
	err = tl.Execute(&buf, b)
	if err != nil {
		panic(err)
	}
	err = ioutil.WriteFile(outFile, buf.Bytes(), 0600)
	if err != nil {
		panic(err)
	}
}

func (b *pkgBuilder) buildPackage() string {
	return strings.Join([]string{
		autogenerated,
		declPkg,
		importsPkg,
		types,
		oneFunc,
		stringFunc,
		cmovFunc,
		caccFunc,
		toBigIntFunc,
		randFunc,
		addFunc,
		subFunc,
		mulFunc,
		sqrFunc,
		bigMulFunc,
		bigSqrFunc,
		redFunc,
		expFunc,
		invFunc,
		"",
	}, "\n")
}

func (b *pkgBuilder) Iter(n uint) []int {
	t := make([]int, n)
	for i := uint(0); i < n; i++ {
		t[i] = int(i)
	}
	return t
}
func (b *pkgBuilder) RevIter(n uint) []int {
	t := make([]int, n)
	for i := uint(0); i < n; i++ {
		t[i] = int(n - 1 - i)
	}
	return t
}

func (b *pkgBuilder) process() {
	p, ok := new(big.Int).SetString(b.Cfg.Prime, 0)
	if !ok {
		panic("error while parsing prime")
	}
	if !p.ProbablyPrime(5) {
		panic("P is not prime")
	}

	b.P.Set(p)
	b.N8 = uint((p.BitLen() + 7) / 8)
	b.Nw = uint((p.BitLen() + bits.UintSize - 1) / bits.UintSize)
	b.Nw2 = b.Nw * 2
	b.R.SetInt64(1)
	b.R.Lsh(&b.R, b.Nw*bits.UintSize)
	oneWord := big.NewInt(1)
	oneWord.Lsh(oneWord, bits.UintSize)
	bigMu := big.NewInt(1)
	bigMu.Neg(p)
	bigMu.ModInverse(bigMu, oneWord)
	b.Mu = uint(bigMu.Uint64())
	b.RmodP.Mod(&b.R, &b.P)
	b.PMinusTwo.SetInt64(2)
	b.PMinusTwo.Sub(&b.P, &b.PMinusTwo)

	fmt.Printf("b.N8 %v\n", b.N8)
	fmt.Printf("b.Nw %v\n", b.Nw)
	fmt.Printf("b.P %v\n", b.P.Text(16))
	fmt.Printf("b.R %v\n", b.R.Text(16))
	fmt.Printf("b.Mu %v\n", b.Mu)
	fmt.Printf("b.P %v\n", b.Hex(&b.P))
	fmt.Printf("b.RmodP %v\n", b.Hex(&b.RmodP))
	fmt.Printf("b.PMinusTwo %v\n", b.Bytes(&b.PMinusTwo))
}

func (b *pkgBuilder) Hex(n *big.Int) string {
	s := ""
	f := fmt.Sprintf("\t0x%%0%vx,\n", 2*(bits.UintSize/8))
	for _, w := range n.Bits() {
		s += fmt.Sprintf(f, w)
	}
	return strings.TrimSpace(s)
}
func (b *pkgBuilder) Bytes(n *big.Int) string {
	s := ""
	by := n.Bytes()
	t := len(by)
	for w := 0; w < t; w++ {
		s += fmt.Sprintf("0x%02x, ", by[t-1-w])
		if w%8 == 7 {
			s = strings.TrimSpace(s) + "\n\t"
		}
	}
	return strings.TrimSpace(s)
}
