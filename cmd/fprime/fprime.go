package main

var autogenerated = `// Code generated by github.com/cloudflare/circl/cmd/fprime DO NOT EDIT.{{"\n"}}`

var declPkg = `// Package {{ .Cfg.PkgName }} {{ .Cfg.PkgDoc }}
package {{.Cfg.PkgName}}`

var declPkgTest = `package {{.Cfg.PkgName}}_test`

var importsTest = `
import (
	"crypto/rand"
	"testing"

	"{{.Cfg.FullPath}}"
)`

var importsPkg = `
import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"
	"math/bits"
)`

var types = `
const (
	// Size in bytes of elements.
	_N8 = {{.N8}}
	// Number of uint words for elements.
	_Nw = {{.Nw}}
	// Montgomery reduction constant -p^-1 mod 2^_Nw.
	_Mu = {{.Mu}}
)

var order = Elem{[_Nw]uint{
	{{.Hex .P}}
}}

var rmodp = Elem{[_Nw]uint{
	{{.Hex .RmodP}}
}}

var pMinusTwo = [_N8]byte{
	{{.Bytes .PMinusTwo}}
}

var errArithmetic = errors.New("arithmetic error")

// Elem is
type Elem struct{ v [_Nw]uint }

type bigElem [2 * _Nw]uint`

var stringFunc = `
func (z Elem) String() string {
	t := z.fromMontgomery()
	s := "0x"
	f := fmt.Sprintf("%%0%vx", 2*(bits.UintSize/8))
	for i := range t.v {
		s += fmt.Sprintf(f, t.v[_Nw-1-i])
	}
	return s
}`

var oneFunc = `
func One() Elem { return rmodp }
func Order() Elem { return order }
func (z *Elem) fromMontgomery() *Elem {
	var t Elem
	t.Mul(z, &Elem{[_Nw]uint{0x1}})
	return &t
}`

var toBigIntFunc = `
func (z *Elem) ToBigInt() *big.Int {
	t := z.fromMontgomery()
	x := make([]big.Word, _Nw)
	for i := range z.v {
		x[i] = big.Word(t.v[i])
	}
	return new(big.Int).SetBits(x)
}`

var randFunc = `
func (z *Elem) Rand(r io.Reader) (n int, err error) {
	b := make([]byte, 8*_Nw)
	n, err = r.Read(b)
	for i := range z.v {
		z.v[i] = uint(binary.LittleEndian.Uint64(b[8*i : 8*(i+1)]))
	}
	return
}`

var cmovFunc = `
// CMov sets z = x if b is different from zero.
func (z *Elem) CMov(x *Elem, b uint) {
	_, c := bits.Sub(0, b, 0)
	m := -c
	for i := range z.v {
		z.v[i] = (z.v[i] &^ m) | (x.v[i] & m)
	}
}`

var caccFunc = `
// cacc conditionally updates z = z+x if b is different from zero.
func (z *Elem) cacc(x *Elem, b uint) uint {
	_, k := bits.Sub(0, b, 0)
	m := -k
	c := uint(0)
	{{- range $i :=.Iter $.Nw}}
	z.v[{{$i}}], c = bits.Add(z.v[{{$i}}], m&x.v[{{$i}}], c)
	{{- end}}
	return c
}`

var addFunc = `
func (z *Elem) Add(x, y *Elem) uint {
	c := uint(0)
	{{- range $i :=.Iter $.Nw}}
	z.v[{{$i}}], c = bits.Add(x.v[{{$i}}], y.v[{{$i}}], c)
	{{- end}}
	fmt.Println(">", c, z)
	c = z.cacc(&rmodp, c)
	fmt.Println(">", c, z)
	c = z.cacc(&rmodp, c)
	fmt.Println(">", c, z)
	if c != 0 {
		panic(errArithmetic)
	}
	return c
}`

var subFunc = `
func (z *Elem) Sub(x, y *Elem) uint {
	c := uint(0)
	{{- range $i :=.Iter $.Nw}}
	z.v[{{$i}}], c = bits.Sub(x.v[{{$i}}], y.v[{{$i}}], c)
	{{- end}}
	return c
}`

var mulFunc = `
func (z *Elem) Mul(x, y *Elem) {
	var t bigElem
	t.Mul(x, y)
	z.red(&t)
}`

var sqrFunc = `
func (z *Elem) Sqr(x *Elem) {
	var t bigElem
	t.Sqr(x)
	z.red(&t)
}`

var bigMulFunc = `
func (z *bigElem) Mul(x, y *Elem) {
	var cc, carry uint
	for i := 0; i < _Nw; i++ {
		hi, lo := bits.Mul(x.v[i], y.v[0])
		z[i], cc = bits.Add(lo, carry, 0)
		carry, _ = bits.Add(hi, 0, cc)
	}
	z[_Nw] = carry

	for j := 1; j < _Nw; j++ {
		carry = uint(0)
		for i := 0; i < _Nw; i++ {
			hi, lo := bits.Mul(x.v[i], y.v[j])
			lo, cc := bits.Add(lo, carry, 0)
			hi, _ = bits.Add(hi, 0, cc)
			z[i+j], cc = bits.Add(z[i+j], lo, 0)
			carry, _ = bits.Add(hi, 0, cc)
		}
		z[j+_Nw] = carry
	}
}`

var bigSqrFunc = `
func (z *bigElem) Sqr(x *Elem) {
	var carry uint
	for j := 0; j < _Nw; j++ {
		carry = 0
		for i := j + 1; i < _Nw; i++ {
			hi, lo := bits.Mul(x.v[i], x.v[j])
			lo, cc := bits.Add(lo, carry, 0)
			hi, _ = bits.Add(hi, 0, cc)
			z[i+j], cc = bits.Add(z[i+j], lo, 0)
			carry, _ = bits.Add(hi, 0, cc)
		}
		z[j+_Nw] = carry
	}

	for i := 2*_Nw - 1; i > 0; i-- {
		z[i] = (z[i] << 1) | (z[i-1] >> (bits.UintSize - 1))
	}

	carry = 0
	for i := 0; i < _Nw; i++ {
		hi, lo := bits.Mul(x.v[i], x.v[i])
		z[2*i+0], carry = bits.Add(z[2*i+0], lo, carry)
		z[2*i+1], carry = bits.Add(z[2*i+1], hi, carry)
	}
}`

var redFunc = `
func (z *Elem) red(x *bigElem) {
	var cout uint
	for i := 0; i < _Nw; i++ {
		carry := uint(0)
		w := _Mu * x[i]
		for j := 0; j < _Nw; j++ {
			hi, lo := bits.Mul(order.v[j], w)
			lo, cc := bits.Add(lo, carry, 0)
			hi, _ = bits.Add(hi, 0, cc)
			x[i+j], cc = bits.Add(x[i+j], lo, 0)
			carry, _ = bits.Add(hi, 0, cc)
		}
		x[i+_Nw], carry = bits.Add(x[i+_Nw], carry, 0)
		for j := i + _Nw + 1; j < 2*_Nw; j++ {
			x[j], carry = bits.Add(x[j], 0, carry)
		}
		cout += carry
	}
	for i := range z.v {
		z.v[i] = x[i+_Nw]
	}
	b := z.cacc(&rmodp, cout)
	if b != 0 {
		panic(errArithmetic)
	}
}`

var expFunc = `
func (z *Elem) Exp(x *Elem, n []byte) {
	t := One()
	for i := 8*len(n) - 1; i >= 0; i-- {
		t.Sqr(&t)
		bit := (n[i/8] >> uint(i%8)) & 0x1
		if bit != 0 {
			t.Mul(&t, x)
		}
	}
	*z = t
}`

var invFunc = `
func (z *Elem) Inv(x *Elem) { z.Exp(x, pMinusTwo[:]) }`
